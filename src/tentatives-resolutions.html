<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <link href="https://fonts.googleapis.com/css2?family=Barlow&family=Quicksand:wght@300&display=swap"
        rel="stylesheet">
    <link rel="stylesheet" href="../css/styles.css">
</head>

<body>
    <header>
        <nav class="navbar">
            <ul>
                <li><a href="../index.html">Accueil</a></li>
                <li><a href="voca.html">Vocabulaire</a></li>
                <li><a href="#">Simulateur</a></li>
                <li><a href=#>Tentatives résolution</a></li>
            </ul>
        </nav>
    </header>

    <h1 class="titre">Tentatives de résolution</h1>

    <main>
        <section class="carte">
            <h2>1. Approche algorithmique</h2>
            <div class="contenu-carte">

                <div class="texte">
                    <p>
                        En se basant sur la définition explicite de la suite de Syracuse compressée, nous pouvons écrire
                        une fonction python pour vérifier si tous les nombres entiers naturels vérifient la conjecture
                        de
                        Syracuse.
                        <br>
                        Le programme se découpe en deux fonctions : <br>
                        - La fonction <code>suite_de_syracuse()</code> prenant en argument un nombre entier et
                        retournant sa suite de Syracuse (compressée) sous la forme d'une liste d'entier <br>
                        - La fonction <code>verifier_tous_les_nombres()</code> qui est celle qui devra être appelée pour
                        lancer le programme.
                        Celle ci utilise une boucle infinie pour tester un à un tous les nombres entiers en utilisant la
                        première fonction. Dès qu'un nombre ne vérifie pas la conjecture, la boucle s'arrête grâce à
                        l'instruction <code>break</code>
                    </p>
                </div>

                <div class="image">
                    <a href="../assets/code.png" target="_blank" rel="noopener noreferrer">
                        <img src="../assets/code.png" alt="Code python">
                    </a>
                </div>
            </div>

            <p>Notre algorithme précédant, bien que fonctionnel, est loin d'être le plus optimal. En effet, celui ci
                test tous les nombres entiers sctrictement supérieur à 0 ce qui n'est pas nécessaire. Pour disqualifier
                d'emblée certains
                nombres, nous pouvons modifier l'énoncé de la conjecture de Syracuse en un nouvel énoncé
                équivalent.En
                effet, nous pouvons affirmer que si tout entier a un temps de vol en altitude fini,
                alors tout vol
                atterit. Cette nouvelle formulation est intéressante dans notre recherche de contre
                exemple
                car elle nous amène à ne chercher que des nombres dont la suite de Syracuse ne passe pas en dessous de
                u<sub>0</sub> tels que : <br>
            </p>

            <div class="contenu-carte">

                <div class="texte">
                    <p>
                        - Les nombres de la forme 2k car ceux ci sont directement divisés par 2 donc u<sub>1</sub>
                        &lt; N <br><br>
                        - Les nombres impairs de la forme 4k + 1 car, par l'application de syracuse, 4k + 1 ⇨ 12k + 4,
                        pair ⇨ 6k
                        + 2, pair ⇨ 3k + 1.<br>
                        3k + 1 &lt; 4k + 1 ⟺ u<sub>3</sub> &lt; u<sub>0</sub>. <br>Le vol des nombres de la
                        forme 4k + 1
                        atterrissent donc. <br><br>
                        - Les nombres de la forme 16k + 3 car <br>⇨48k + 10 ⇨ 24k + 5 ⇨ 72k + 16 ⇨ 36k + 8
                        ⇨ 18k + 4 ⇨ 9k + 2 <br>
                        9k + 2 &lt; 16k + 3 ⟺ u<sub>6</sub> &lt; u<sub>0</sub>. <br> Les nombres de la forme 16k + 3
                        atterrissent donc. <br> <br>
                    </p>
                </div>

                <div class="image">
                    <a href="../assets/code_opti.png" target="_blank" rel="noopener noreferrer">
                        <img src="../assets/code_opti.png" alt="Code Python">
                    </a>
                </div>
            </div>
            <p>
                Par des calculs analogues, nous prouvons prouver que plus de 90% des nombres entiers
                naturels
                sont inutiles à testercar nous prouvons prouver que leur vol en altitude est fini.
                Ainsi, seuls
                les nombres impairs de la forme 16k+7, 16k + 11 ou 16k + 15 peuvent être des prétendants à un
                contre exemple. En effet, nous ne pouvons pas prouver avec exactitude que ces vols atterissent
                car leur comportement varie en fonction des nombres.
            </p>
        </section>

    </main>
</body>

</html>